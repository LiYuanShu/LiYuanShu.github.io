<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小树窝">
<meta property="og:url" content="https://LiYuanSh.github.io/index.html">
<meta property="og:site_name" content="小树窝">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小树窝">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://LiYuanSh.github.io/"/>





  <title>小树窝</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小树窝</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/15/运维实战二-网关-防火墙功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/运维实战二-网关-防火墙功能/" itemprop="url">运维实战二-网关:防火墙功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-15T20:12:24+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本次实验使用的架构和上一个实验<a href="https://liyuanshu.github.io/2019/08/13/%E8%BF%90%E7%BB%B4%E5%AE%9E%E6%88%98%E4%B8%80-%E7%BD%91%E5%85%B3%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/#more" target="_blank" rel="noopener">网关：路由功能</a>的架构大致相同，也需要在上一个实验的基础上，才能完全实现这一个实验的全部功能。<br>说明：外网为ens33对接，内网为ens38、ens39对接<br><img src="/images/iptables1.jpg" alt="架构图"><br><strong>需要实现以下任务</strong><br>1、 从外网向内网主机主动发起的 请求，不能进入内部网络<br>    防火墙主机，仅允许内网主机 ping ，不回应外部主机的 ping 包。<br>2、 防火墙主机，开放 80 端口服务，仅提供给 内部主机访问<br>3、 防火墙主机，开放 22 端口服务，仅允许 内网的  管理员IP 访问，绑定MAC地址<br>4、 所有内网主机 要求能够通过  防火墙主机 正常访问（百度）</p>
<h4 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h4><p>从外网向内网主机主动发起的 请求，不能进入内部网络防火墙主机，仅允许内网主机 ping ，不回应外部主机的 ping 包。<br>核心规则—–反向思维实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -P INPUT DROP                               ##全局规则</span><br><span class="line">iptables -t filter -A INPUT ! -i ens33 -p ICMP -j ACCEPT        ##非ens33网卡放行</span><br></pre></td></tr></table></figure></p>
<p>外网效果：<br><img src="/images/iptables2.jpg" alt="效果"><br>内网效果：<br><img src="/images/iptables3.jpg" alt="效果"></p>
<h4 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h4><p>防火墙主机，开放80端口服务，仅提供给 内部主机访问<br>核心规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -P INPUT DROP</span><br><span class="line">   iptables -t filter -A INPUT -i ens38 -p tcp --dport 80 -j ACCEPT</span><br><span class="line">   iptables -t filter -A INPUT -i ens39 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>外网效果：<br><img src="/images/iptables4.jpg" alt="效果"><br>内网效果（ elinks <a href="http://192.168.1.4" target="_blank" rel="noopener">http://192.168.1.4</a> ）：<br><img src="/images/iptables5.jpg" alt="效果"></p>
<h4 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h4><p>防火墙主机，开放 22 端口服务，仅允许 内网的  管理员IP 访问，绑定MAC地址<br><strong>前提——-设定内网的管理者为server3———IP：192.168.60.5———MAC：00:0c:29:ba:7e:0e</strong><br>核心规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -P INPUT DROP</span><br><span class="line">iptables -t filter -A INPUT -s 192.168.60.5 -p TCP --dport 22 -m mac --mac-source 00:0c:29:ba:7e:0e -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>server3连接：<br><img src="/images/iptables7.jpg" alt="效果"><br>其他主机连接：<br><img src="/images/iptables6.jpg" alt="效果"></p>
<h4 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h4><p>所有内网主机 要求能够通过  防火墙主机 正常访问（百度）</p>
<p>允许建立连接并且完全有效的包通行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -A INPUT -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<p>server2可以正常访问外网：<br><img src="/images/iptables8.jpg" alt="效果"></p>
<p>允许所有的数据包可以经过forward检查点<br>snat技术把原地址转换，只要转换为server2主机中三张网卡的任意一个IP地址即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -P FORWARD ACCEPT</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.60.0/24 -o ens33 -j SNAT --to 192.168.1.4</span><br><span class="line">iptables -t nat -A POSTROUTING -s 55.168.10.0/24 -o ens33 -j SNAT --to 55.168.10.4          </span><br><span class="line"> ```  </span><br><span class="line">![效果](/images/iptables9.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">防火墙规则脚本</span><br></pre></td></tr></table></figure></p>
<p>#!/bin/bash<br>iptables -t filter -F<br>iptables -t nat -F<br>iptables -t filter -Z<br>iptables -t nat -Z<br>iptables -t filter -X<br>iptables -t nat -X</p>
<p>#########INPUT#############<br>iptables -t filter -P INPUT DROP<br>iptables -t filter -A INPUT -s 192.168.1.1 -p TCP –dport 22 -j ACCEPT<br>iptables -t filter -A INPUT -m state –state ESTABLISHED -j ACCEPT<br>iptables -t filter -A INPUT ! -i ens33 -p ICMP -j ACCEPT<br>iptables -t filter -A INPUT -i ens38 -p tcp –dport 80 -j ACCEPT<br>iptables -t filter -A INPUT -i ens39 -p tcp –dport 80 -j ACCEPT<br>iptables -t filter -A INPUT -s 192.168.60.5 -p TCP –dport 22 -m mac –mac-source 00:0c:29:ba:7e:0e -j ACCEPT</p>
<p>#########FORWARD,POSTROUTING#########<br>iptables -t filter -P FORWARD ACCEPT<br>iptables -t nat -A POSTROUTING -s 192.168.60.0/24 -o ens33 -j SNAT –to 192.168.1.4<br>iptables -t nat -A POSTROUTING -s 55.168.10.0/24 -o ens33 -j SNAT –to 55.168.10.4</p>
<p><code>`</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/15/运维笔记六-TCP模型相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/运维笔记六-TCP模型相关/" itemprop="url">运维笔记六-TCP/UDP相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-15T08:45:38+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算机数据传输的模型图（一般现在按四层模型划分）：<br><img src="/images/六tcp.jpg" alt="数据传输模型"></p>
<p>传输层主要存在两个协议：<br>    TCP：面向连接–三次握手、四次挥手；保证高可靠性(数据无丢失—-重传机制、数据有序传输、数据无错误—-校验码、数据无重复到达)<br>    UDP：无连接,不可靠传输，常用于视频播放之类</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP头部正常情况下包含20个字节，主要包含以下内容：<br>    端口号—–源端口(客户端浏览器打开的端口)占两个字节—-8位<br>               目标端口(服务回应端口)占两个字节—-8位<br>        注：常用服务及其端口端口（FTP：21  SSH：22  Telnet：23  SMTP：25 http：80  https：443  Mysql：3306）<br>    序号——-发送序号(seq)占四个字节<br>               确认序号(ack)占四个字节<br>         注：ack一般为seq的数字加一，但所传输的包数量超过(2^16)时，会重新归零<br>    偏移量—–标识TCP的实际使用长度占一个字节(4位)—-得出TCP最长字节数为60<br>    标志位—–占6位，值为1代表启用<br>        URG  紧急指针，不用吧这个报文放入缓冲区，直接交个上层处理<br>        ACK  确认序号有效<br>        PSH  立即把报文放入缓冲区，并且把缓冲区的内容一起交个上层处理<br>        SYN  同步序号用来发去一个连接<br>        FIN  发送端完成发送任务（断开连接）<br>        RST  表示断开一个连接（访问出错时使用）<br>    窗口大小—表示能够接受tcp报文的最大字节数(16位)，控制发送报文大小<br>    校验和—–验证报文的正确性(16位)</p>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="/images/六tcp1.jpg" alt="数据传输模型"><br>注：三次握手只是建立连接的过程，期间无任何数据传输。</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="/images/六tcp2.jpg" alt="数据传输模型"><br>注：四次挥手服务端和客户端皆可以先发起，如果客户端有一段时间再无任何请求，则一般由服务端发起(节约资源)。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP头部非常简单，只占用8个字节。<br>    端口号—–源端口(客户端浏览器打开的端口)占两个字节—-8位<br>               目标端口(服务回应端口)占两个字节—-8位<br>    length—–占两个字节，标识UDP头部的长度<br>    Checksum—校验和，包含UDP头和数据部分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/13/运维实战一-网关：路由功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/13/运维实战一-网关：路由功能/" itemprop="url">运维实战一-网关：路由功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-13T18:12:02+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>路由：一个设备从接口(网卡)上接收到数据包，依据设备所使用的某些规则，将数据包转发到其他接口的过程。
</code></pre><p>本项目有四台虚拟机构成，三台处于不太的网段，一台设置为路由器，实现数据转发功能。<br><img src="/images/路由转发1.jpg" alt="架构图"></p>
<h4 id="接入虚拟交换机"><a href="#接入虚拟交换机" class="headerlink" title="接入虚拟交换机"></a>接入虚拟交换机</h4><p>根据架构图，创建出四台虚拟机，并且分别接入到对应的虚拟交换机中。<br><img src="/images/路由转发2.jpg" alt="交换机"></p>
<h4 id="初步设置ip"><a href="#初步设置ip" class="headerlink" title="初步设置ip"></a>初步设置ip</h4><p>将三台虚拟机设置成相对应的IP，同时注销掉网关设置。还需要注意子网掩码方面的设置(本次实验皆为C类IP地址，使用默认子网掩码)。例如server1虚拟机的配置文件和路由表信息如下：<br><img src="/images/路由转发3.jpg" alt="server1"><br>由server1第一次ping主机server3：<br><img src="/images/路由转发4.jpg" alt="server1"><br>原因：server1主机的route表中无此网段的记录，提示目标不可达，由自己提示</p>
<p>在server1主机添加一条路由信息：route add -net 192.168.60.0 netmask 255.255.255.0 gw 192.168.1.5<br><img src="/images/路由转发5.jpg" alt="server1"><br>数据包已经发出，但是一直无返回信息，原因是数据包一直往server2主机的192.168.1.5这个网卡发送信息，但是对方接收到数据包后发送目标地址并不是自己，因此一直把数据包丢掉。</p>
<p>打开server2主机的核心路由转发功能<br>vim   /etc/sysctl.conf   在最后一行添加：net.ipv4.ip_forward = 1<br><img src="/images/路由转发6.jpg" alt="vim信息"><br>验证是否成功：在bash中执行： sysctl -p   会出现 net.ipv4.ip_forward = 1 这个信息。</p>
<p>在server1中再次ping和主机server3统一网段的地址，但是该主机不存在：<br><img src="/images/路由转发7.jpg" alt="vim信息"><br>会由主机server2提示目标主机不可达</p>
<p>在server3主机添加一条路由信息：route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.60.4<br>可以发现两台主机ping通了！！！！！！</p>
<h4 id="意外总结"><a href="#意外总结" class="headerlink" title="意外总结"></a>意外总结</h4><p>在server2添加一条默认网关(route add default gw 192.168.1.2)<br>|<br>server1通过把网关指向server2可以上网<br>server3、server4通过把网关指向server2不可以上网<br>|<br>原因：vmnet8号交换只会把192.168.1.0/24网段的IP通过NAT技术在出栈时把IP换为win10IP，数据包回来时再换回原IP地址<br>而server3、server4主机不属于这一网段</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/12/运维笔记五-IP地址那点事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/运维笔记五-IP地址那点事/" itemprop="url">运维笔记五-IP地址那点事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T20:21:20+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>IP地址用来表示互联网上主机的编号，互联网上主机之间都需要利用IP地址进行通信。IP地址由网络号和主机号组成(网络号决定网络数量，主机号决定主机数量)。
**网络号和主机号不能全部为0**
**最高的网络号&quot;位&quot;必须为0**
</code></pre><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h4><p><img src="/images/ip1.jpg" alt="A类IP"><br>网络数量：126-1+1=126<br>主机数量：256<em>256</em>254<br>A类私有网络段地址：<strong>10.0.0.0—10.255.255.254</strong></p>
<h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h4><p><img src="/images/ip2.jpg" alt="B类IP"><br>网络数量：(191-128+1)<em>(254-1+1)=16256<br>主机数量：256</em>254<br>A类私有网络段地址：<strong>172.16.0.0—172.31.255.254</strong></p>
<h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h4><p><img src="/images/ip3.jpg" alt="C类IP"><br>网络数量：(223-192+1)<em>(255-0+1)</em>(254-1+1)<br>主机数量：255<br>A类私有网络段地址：<strong>172.16.0.0—172.31.255.254</strong></p>
<p>总结：A—-B——C类的IP地址：网络段数量逐步递增，每个网络段的主机数逐步减少<br>注：127.0.0.1为回环网卡地址。访问本机服务时使用</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>主要用于划分网络段，形成更多的局域网，有利于避免ARP广播风暴<br> 标准子网掩码：划分A、B、C类网络IP地址时使用<br> 非标准子网掩码：一个标准的网络段可能包含的IP地址很多，现实情况中一般需要划分为更多、更小的局域网，因此一般需要重新划分子网掩码。</p>
<p>分辨两个IP地址是否处于同一个网段，需要两个已知条件：IP地址、子网掩码。</p>
<ol>
<li>把IP地址和子网掩码转化为二进制表示</li>
<li><p>分别对IP地址和子网掩码的二进制位进行与运算（只有1与1组合，结果才为1，其余为零）</p>
<p>练习例子：<br>1、 172.16.0.0   使用  255.255.248.0  子网掩码， 划分成了多少个子网，每个子网中有多少个可用 IP地址<br>  写出  其中  三个以上的 网段。<br>  B类地址：  172.16.0.0</p>
<pre><code>1010 1100。0001 0000。0000 0000。0000 0000
1111 1111。1111 1111。0000 0000。0000 0000
1111 1111。1111 1111。1111 1000。0000 0000
1010 1100。0001 0000。0000 0000。0000 0000----------------1010 1100。0001 0000。0000 1000。0000 0000
1010 1100。0001 0000。0000 1000。0000 0000----------------1010 1100。0001 0000。0000 0111。1111 1111
  2的五次方====32个子网
  2的十一次方====2048个可用IP（减去网络号和广播地址  2046个）
 172.16.0.0----------172.16.7.255  /21
 172.16.8.0----------172.16.15.255 /21
  172.16.8.0----------172.16.23.255 /21
</code></pre></li>
</ol>
<p>2、  172.16.0.99   /  255.255.248.0<br>    172.16.1.99   /  255.255.248.0       </p>
<pre><code>## 这两个 IP 地址是否属于同一网段？
172.16.0.99          1010 1100。0001 0000。0000 0000。0110 0011
255.255.248.0        1111 1111。1111 1111。1111 1000。0000 0000
---------------------------------------------------------------------------------------------------------------
                                                    0000 0000

172.16.1.99          1010 1100。0001 0000。0000 0001。0110 0011
255.255.248.0        1111 1111。1111 1111。1111 1000。0000 0000
-----------------------------------------------------------------------------------------------------------------
                                                    0000 0000                                                                     
**运算结果相同，处于同一网段**
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/12/运维笔记四-网络通信发展史/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/运维笔记四-网络通信发展史/" itemprop="url">运维笔记四-网络通信发展史</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T18:58:01+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原始时期"><a href="#原始时期" class="headerlink" title="原始时期"></a>原始时期</h3><pre><code>电脑之间通信需要使用网线两两连接起来，需要消耗的资源巨大
</code></pre><p><img src="/images/网络1.jpg" alt="网络通信1"><br>当连接的数量越多时，需要使用的资源越多，并且网线之间对应的主机、网线接口的需求都是一系列大问题<br>问题源：两台主机之间通信，当一台主机发出信息的时候不能同时接受信息(半双工工作状态)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两台主机之间连接2根线缆(双绞线)，全双工模式工作</span><br></pre></td></tr></table></figure></p>
<h3 id="集线器时期"><a href="#集线器时期" class="headerlink" title="集线器时期"></a>集线器时期</h3><p>定义：用于连接多条网线、让多个终端能够通信的一种信号转发设备<br>优点：分隔开各个终端设备（一个终端的线路出现故障，其他设备不收影响）<br>功能：对接受到的信号进行再生放大，扩大网络传输距离。<br><img src="/images/网络2.jpg" alt="网络通信2"><br>集线器的发明，大大减少了资源的浪费，但是也引出了一系列问题<br>问题源一：当一个主机发出信息时，如何知道由那个目标主机接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址广播：IP地址查询(人类易记)，映射得出MAC</span><br><span class="line">MAC出现，为每台主机的唯一识别标志</span><br></pre></td></tr></table></figure></p>
<p>问题源二：冲突域的产生(争用同一底层信道的主机集合)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一. CSMA/CD：载波侦听，多路访问控制/冲突检测</span><br><span class="line">	发送信号前，先进行检测，一旦有空闲，则立刻发送信号，边发送边监听，遇到冲突，立刻停止，并后退</span><br><span class="line">AB同时发送，刚好冲突，两者都后退，再挑选随机时间，再次侦听。(使用此机制，成为Ethernet,以太网，免费)</span><br><span class="line">二. 令牌环，拥有令牌环的主机优先发送数据（IBM专利，付费）</span><br><span class="line">三. 环形网络</span><br></pre></td></tr></table></figure></p>
<h3 id="网桥-交换机时代"><a href="#网桥-交换机时代" class="headerlink" title="网桥/交换机时代"></a>网桥/交换机时代</h3><p>定义：能够让多台不同网段的主机实现同时通信的一种设备。<br>优点：为集线器的升级版，解决了冲突域问题<br><img src="/images/网络3.jpg" alt="网络通信3"><br>解决冲突域是因为使用了物理闭合电路，形成独立路径传输数据，同时也添加了MAC表，加快了传输速度<br><img src="/images/网络4.jpg" alt="网络通信4"></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>交换机也是网桥的升级版，可以认为交换机就是多个网桥的集合，当然两个之间还是存在着很多的不同点：<br>（1）交换机工作时，实际上允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。即网桥一般分有两个端口，而交换机具有高密度的端口。<br>（2）分段能力的区别<br>　　由于交换机能够支持多个端口，因此可以把网络系统划分成为更多的物理网段，这样使得整个网络系统具有更高的带宽。而网桥仅仅支持两个端口，所以，网桥划分的物理网段是相当有限的。<br>（3）传输速率的区别<br>　　交换机与网桥数据信息的传输速率相比，交换机要快于网桥。<br>（4）数据帧转发方式的区别<br>　　网桥在发送数据帧前，通常要接收到完整的数据帧并执行帧检测序列FCS后，才开始转发该数据帧。交换机具有存储转发和直接转发两种帧转发方式。直接转发方式在发送数据以前，不需要在接收完整个数据帧和经过32bit循环冗余校验码CRC的计算检查后的等待时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/10/运维笔记三-字符处理三剑客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/10/运维笔记三-字符处理三剑客/" itemprop="url">运维笔记三-字符处理三剑客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-10T10:24:19+08:00">
                2019-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全称 Global search Regular Expression and Printing，提取文本内容的整行，执行速度快，适合大篇幅文本信息处理。<br>grep家族<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep   默认的基础正则表达式</span><br><span class="line">egrep  扩展正则表达式（相当于 grep -E）</span><br><span class="line">fgrep 不支持正则表达式或者元字符，搜索字符串速度快</span><br></pre></td></tr></table></figure></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>语法： grep [options] &quot;搜索条件(正则表达式)&quot; file
                -n       显示搜索结果处于原文件的行号
                -v       取反，只显示不符合条件的行内容
                -o       只显示被匹配到的字符串，而不是整行
                -i       不区分大小写
                -A  num 显示匹配到的行，同时附加多显示该行后的num行
                -B  num 显示匹配到的行，同时附加多显示该行前的num行    
                -E      使用扩展正则表达式
</code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>  sed主要用于文本替换、删除。其工作模式一般为逐行处理，处理过程会产生处理空间、结果空间。处理过程如下：<br>  <img src="/images/sed.jpg" alt="sed处理过程"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，不会文件本身进行操作（-i  表示改变文件，慎用）</span><br><span class="line">默认情况下，sed会先读取文件所有行（可使用定界来确定文件读取的范围行）</span><br><span class="line">若在模式空间中数据不符合匹配规则，则不作处理，直接原样输出</span><br></pre></td></tr></table></figure></p>
<h4 id="sed用法"><a href="#sed用法" class="headerlink" title="sed用法"></a>sed用法</h4><p>语法： sed [options] ‘[定界/条件]{[动作]/[模式匹配空间]/[动作补充]}’ file<br>    [options]<br>       -n  静默模式，不输出模式空间的内容，一般拥有 p 操作<br>       -e  指定一个sed命令中执行多个动作。格式：sed -e ‘1{p}’ -e ‘2{p}’ file<br>       ;   指定一个sed命令中执行多个动作,与-e效果一样。格式：sed ‘1{p};2{p}’ file<br>       -i  直接修改原文件<br>       -r  支持使用正则表达式<br>       -f  从文件中读取处理脚本，并执行<br><img src="/images/sed1.jpg" alt="sed -f"></p>
<pre><code>定界/条件
    1,7----第一到第七行
    1,$ (1,)-----第一到最后一行
    1,/正则/-----1,/^d/第一行到开头是d的那一行
    /正则/,/正则/
    /正则/-------/^d/匹配开头是d的所有行
动作
    p             打印-----sed -n &apos;1{p}&apos; file 
    d             删除
    a\text       在符合条件的行添加指定内容（可使用 \n  实现换行---多行添加）
    i\text       在符合条件的行添加指定内容-----sed &apos;1 i\22&apos; file 
    c\text      符合条件的行替换为指定文本内容
    r /path     在符合条件的文章追加指定文件内容---sed &apos;/^root/r /file&apos; /etc/passwd
    w /path     将符合条件的行，保存到指定文件中；覆盖式输出，能自动创建文件
    s/查找的内容/替换的内容/    &amp;可以表示查到到的内容----sed  &apos;{s/root/&amp;s/g}&apos;  passwd 
              补充标志位： /i  忽略大小写
                            /g  全局替换
</code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk是一个非常强大文本处理工具，具有查找、切割、替换功能。程序执行分为三个部分：BEGIN段、主程序段、END段<br><img src="/images/awk.jpg" alt="awk处理过程"></p>
<p>语法： awk -F “列分隔符”  ‘BEGIN{} /模式空间–条件匹配|正则/{对每行的执行动作} END{}’</p>
<p>模式空间–匹配条件常用方法：<br>    数值之间的比较： &gt;  &lt;  &gt;=  &lt;=  ==  !=    ($2&gt;=2)<br>    字符之间的比较：~   !~    例：awk -F “:” ‘$2 ~ “li”{print $2}’ file<br>    字符之间正则表达式：  ~   !~   /正则|正则/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">支持数值运算：++、--、+=、-=、*=、/=、%=、^=、**=</span><br><span class="line">支持逻辑运算符： &amp;&amp;   ||</span><br></pre></td></tr></table></figure>
<h4 id="内置变量理解"><a href="#内置变量理解" class="headerlink" title="内置变量理解"></a>内置变量理解</h4><p>FS(field separator)：  读取文件行时指定用的列分隔符(默认为空格，可自定义)<br>RS(Record separator)： 读取文件指定的行分隔符(默认为换行符)<br>OFS(Output Filed Separetor): 输出时可以指定列字段分隔符，默认为空格<br>ORS(Output ROw Sepaertor): 输出时指定行分隔符，默认为换行符(/n)<br>NR(The number of input records): 显示当前正在处理的行编号<br>NF(Number of field): 统计每行分割列后的的总列数<br>FNR:当同时操作两个文件时，每一个文件的行号从头开始<br>ARGV：数组，保存命令本书这个字符串，如： <code>awk &#39;{print $0}&#39; file</code>—–ARGV[0]:awk; ARGV[1]:file<br>ARGC:统计ARGV的总个数<br>FILENAME: 当前正在处理的文件名称<br>ENVIRON：当前shell环境变量—-ENVIRON[“HOSTNAME”]<br><img src="/images/awk1.jpg" alt="awk内置变量使用"></p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p>split(string ,array,分隔符)：对字符串进行切割，然后存放在array中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;a=&quot;a,r,5 6h j&quot;;split(a,cc,&quot; &quot;)&#125;END&#123;for(i in cc) print cc[i]&#125;&apos; file</span><br><span class="line">输出：</span><br><span class="line">a,r,5</span><br><span class="line">6h</span><br><span class="line">j</span><br></pre></td></tr></table></figure></p>
<p>substr(string,start,length):从字符串第start位开始，截取长度为length的子字符串(字符串下标从1 开始)</p>
<p>system(“bash环境下的命令”):相当于搭建了一个shell工作环境</p>
<p>tolower(string): 将字符串全部转化为小写<br>toupper(string): 将字符串全部转化为大写</p>
<h4 id="支持循环判断语句"><a href="#支持循环判断语句" class="headerlink" title="支持循环判断语句"></a>支持循环判断语句</h4><p>   if-else语句：<br>           awk - F:    ‘{  if($1 ~ /mail/ &amp;&amp; $3&gt;8)  print $0  }’ /etc/passwd</p>
<pre><code>while语句：
     while (condition){statement1; statment2; ...}

for循环：
     for ( variable assignment; condition; iteration process) { statement1, statement2, ...}
</code></pre><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><pre><code>定义一个数组：
    awk &apos;BEGIN{avgs[0]=&quot;hulk&quot;;avgs[1]=&quot;natasha&quot;;avgs[2]=&quot;thor&quot;;avgs[3]=&quot;&quot;print avgs[2]}&apos;

判断一个数组元素是否存在：
    可以使用语法 &quot;if(下标 in 数组名)&quot; ，从而判断数组中是否存在对应的元素。 可以使用 &quot;!&quot; 对条件进行取反

遍历数组：
    for(i in array){.....}

对数组元素使用操作符：
    如果我们操作的某个元素 是不存在的话，awk 会默认自动创建该元素，并将它的初始值设置为 0 
    awk 支持对 直接对数组中的 “空元素” 使用操作符。

 可以使用管道操作符，但是只能使用一次，并且管道符后面的命令需要使用&quot;&quot;引用起来
</code></pre><h4 id="printf高级用法"><a href="#printf高级用法" class="headerlink" title="printf高级用法"></a>printf高级用法</h4><pre><code>使用格式：
    printf   &quot;format1  [可选自定义字符]  format2  format3&quot; , item1, item2, item2 ...

常用字符表示：
    %c:                显示第一个参数的第一个字符  
    %d, %i：       十进制整数；
    %u:               无符号整数；
    %e, %E：      科学计数法显示数值；
    %f:               显示浮点数；
    %g, %G:       以科学计数法的格式或浮点数的格式显示数值；       
    %s:              显示字符串； 
    %%:             显示%自身；
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/07/运维笔记二-正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/运维笔记二-正则表达式/" itemprop="url">运维笔记二-正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-07T20:05:27+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正则表达式(字符)是一种字符模式，用于查找过程中匹配指定字符。</p>
<h3 id="常用正则元字符"><a href="#常用正则元字符" class="headerlink" title="常用正则元字符"></a>常用正则元字符</h3><p>   元字符指在正则表达式中拥有特殊含义，不再是表明含义。</p>
<pre><code>元字符/其他  |  含义
  ^ [^]      | 第一个表示开头  第二个表示对[]里的字符取反
  $          | 表示字符结尾
  *          | 表示0次或者多次
   .         | 任意字符
   \         | 用于转义字符
  \(\)       | 对字符分组， 定义再次出现此字符分组--\(\).*\1
  []         | 指定[]里面指定一个人员字符，一般可以尝试把一些有歧义的字符放在里面【. \】
  \{\}       | 指定某些字符出现的次数，\{1\}--一次   \{1,3\}---1到3次    \{1,\}---至少一次
  \&lt;\&gt;      | 锚定一个单词(以符号或者空格、换行符之类为单词分隔符)，可以拆分使用\&lt;---锚定词首，\&gt;----锚定词尾
</code></pre><h3 id="扩展正则"><a href="#扩展正则" class="headerlink" title="扩展正则"></a>扩展正则</h3><p>  扩展正则增加了几个元字符，同时也让一些元字符使用变得更简单(分组、限定出现次数的不需要使用转义字符)</p>
<pre><code>元字符/其他  |  含义
  +              | 匹配前一个字符出现一次或者多次
  ?          | 匹配前一个字符出现零次或者多次
  |         | 或条件
</code></pre><h3 id="常用字符匹配"><a href="#常用字符匹配" class="headerlink" title="常用字符匹配"></a>常用字符匹配</h3><p>[0-9]———匹配0到9数字<br>[a-Z]———匹配字母<br>[:alnum:]—–字母与数字<br>[:alpha:]—–字母字符（包括大小写字母）<br>[:balnk:]—–空格与制表符<br>[:digit:]—–数字字符<br>[:lower:]—–小写字母<br>[:upper:]—–大写字母<br>[:punct:]—–标点符号<br>[:space:]—–包括换行符、回车等所有的空白</p>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><p>三剑客中使用：<br>grep匹配文件的某一行时<br>    grep  “z正则表达式”（-i 不区分大小写； -E 支持扩展正则）<br>awk匹配某一列内容    ~   !~ /正则表达式/<br>sed   定界/正则表达式/</p>
<p>脚本中使用—-if判断<br>if [ var =~ 正则表达式 ]</p>
<p>nginx服务配置文件中，通过正则表达式匹配相对应的目录<br>location [=|~| ~<em> | !~ | ~</em> | ^~]  /URL(正则表达式)/{ …. }<br>=   表示精确匹配，优先级第一<br>^~  表示URL某个常规字符串开头，理解为匹配url路径即可，优先级第二<br>~   表示区分大小写的正则匹配，优先级第三（！~  取反）<br>~*  表示不区分大小写的正则匹配，优先级第三（！~  取反）<br>/   通用匹配，任何请求都会被匹配到 优先级第四 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/08/05/运维笔记一-常用命令的常用选项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/运维笔记一-常用命令的常用选项/" itemprop="url">运维笔记一:常用命令的常用选项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T19:55:22+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>ls主要为查看一个文件夹目录下存放的内容（普通文件、目录、软链接、设备…）</p>
<pre><code>命令选项  |  作用
 -a       | 列出所有文件
 -l      | 按照文件名称默认排序
 -S      | 按照文件的大小排序，从大到小
 -t      | 显示mtime并mtime排序，新的在前面
 -ct     | 显示ctime并且排序，新的排前面
</code></pre><p>  补充：atime—–文件被修改后（元数据、内容）第一次被访问的时间<br>          mtime—–文件内容最后被修改时间<br>          ctime—–文件元数据发生变化。比如权限，所有者</p>
<h3 id="cat、head、tail命令"><a href="#cat、head、tail命令" class="headerlink" title="cat、head、tail命令"></a>cat、head、tail命令</h3><p>cat主要用于查看文件内容</p>
<pre><code>命令选项  |  作用  
 -A       | 展示文件所有内容，常用于查看文件的特殊编码字符
 -n      | 给文件每一行前加一个编号
 -v      | 查看所有隐藏字符
</code></pre><p>head主要用于去文件的头几行内容</p>
<pre><code>命令选项  |  作用
-n   1     | 指定查看文件第一行
 -n -1   | 不显示文件最后一行
</code></pre><p>tail用法与head用法相似（tail -n +1）</p>
<h3 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h3><p>wc主要用于统计文件信息</p>
<pre><code>命令选项  |  作用
 -l       | 统计一个文件行数
 -w      | 统计一个文件的字数，由空白、跳格、换行分割
 -v      | 查看所有隐藏字符
</code></pre><h3 id="sort、uniq"><a href="#sort、uniq" class="headerlink" title="sort、uniq"></a>sort、uniq</h3><h4 id="uniq的使用一般要结合sort，例如uniq-c-统计行数只会统计相邻之间的重复行数，若不先进行排序，直接统计很容易出现结果错误"><a href="#uniq的使用一般要结合sort，例如uniq-c-统计行数只会统计相邻之间的重复行数，若不先进行排序，直接统计很容易出现结果错误" class="headerlink" title="uniq的使用一般要结合sort，例如uniq -c 统计行数只会统计相邻之间的重复行数，若不先进行排序，直接统计很容易出现结果错误"></a>uniq的使用一般要结合sort，例如uniq -c 统计行数只会统计相邻之间的重复行数，若不先进行排序，直接统计很容易出现结果错误</h4><p>sort主要用于排序作用</p>
<pre><code>命令选项  |  作用
 -f       | 忽略字符大小写
 -n      | 以数值大小排序
 -r      | 查看所有隐藏字符
 -u      | 删除重复行
 -R      | 随机排序 （实现随机抽选功能）
 -t      | 指定排序依据的分隔符，默认为空格
 -k      | 指定以第几列为排序依据
</code></pre><p>-t -k一般结合使用方能生效—–[root@server1 /test]# ll | sort -nt月 -k 2</p>
<p>uniq——重复行数的统计</p>
<pre><code>命令选项  |  作用
 -c       | 统计重复行数的次数
 -u      | 只显示没有重复的行数
 -d      | 只显示重复过的行数
</code></pre><h3 id="简易版的sed、awk工具"><a href="#简易版的sed、awk工具" class="headerlink" title="简易版的sed、awk工具"></a>简易版的sed、awk工具</h3><p>tr——sed的简易版本，一般拥有字符处理</p>
<pre><code>命令选项  |  作用                      | 示例
 -d  &quot;&quot;  | 删除该文件的所有字符集合     | cat file -d &quot;1&quot; --把file的所有”1“删除
 &apos;&apos;  &apos;&apos;  | 字符替换                    | cat file &apos;12&apos; &apos;34&apos; --把file的所有1换成3，2换成4
</code></pre><p> cut——-awk的简易版本，切割字符分列</p>
<pre><code>命令选项  |  作用
 -d       | 指定列切割符，默认为空格
 -f      | 选择输出的那些列
</code></pre><p>示例： cat file | cut -d: -f 1-3,5———–以:为分隔符，输出1,2,3,5列</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/04/20/python——Gevent协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/20/python——Gevent协程/" itemprop="url">Gevent协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-20T10:22:00+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>安装：pip install gevent</p>
<h3 id="协程定义"><a href="#协程定义" class="headerlink" title="协程定义"></a>协程定义</h3><p>   又名微线程，纤程。在不开辟线程的基础上完成多任务，即在单线程情况下完成多任务，多个任务按照一定顺序交替执行。可认为看到yield关键字就是协程。本质为是个单线程。<br>   协程是实现多任务的一种方法。<br>   <img src="/images/协程.JPG" alt="生成.spec文件"><br>       缺点：无法利用多核资源<br>    优点：提高执行效率————–无需线程的切换开销。<br>         高可用+高扩展性+低成本——一个CPU可支持上万个协程（高并发）；<br>         不需要多线程的锁制作——–如生产者-消费者问题。传统方法需要使用两个线程，但如果使用在一个线程中使用关键字yield开辟协程便可解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">   import time</span><br><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.next()</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br><span class="line"></span><br><span class="line"> 执行结果：</span><br><span class="line"> [PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">注：[代码来源参考](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)</span><br></pre></td></tr></table></figure></p>
<h3 id="协程使用"><a href="#协程使用" class="headerlink" title="协程使用"></a>协程使用</h3><p>使用安装：cmd下执行命令：pip install greenlet<br>使用一个简单例子解释greenlet用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import time,greenlet</span><br><span class="line">def work1():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&apos;---work1-----&apos;)</span><br><span class="line">        time.sleep(0.5)</span><br><span class="line">        ##切换协程</span><br><span class="line">        g2.switch()</span><br><span class="line">def work2():</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&apos;---work2-----&apos;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        g1.switch()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    g1=greenlet.greenlet(work1)</span><br><span class="line">    g2=greenlet.greenlet(work2)</span><br><span class="line">    g1.switch()</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">---work1-----</span><br><span class="line">---work2-----</span><br><span class="line">---work1-----</span><br><span class="line">---work2-----</span><br></pre></td></tr></table></figure></p>
<p>greenlet可以实现协程，但需要人工切换，很多场景不适用。因此更多时候我们使用一个更强大的库————Gevent。</p>
<h3 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h3><p>使用安装：在cmd中输入命令：pip install gevent<br>    Gevent内部封装Greenlet，其原理相当于一个Greenlet遇到IO操作【网络、文件操作】时，自动切换到其他Greenlet，等到这个IO操作完成，在适当时候切换回来执行。</p>
<p>例子使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line">def work(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        ##获取当前协程的属性</span><br><span class="line">        print(gevent.getcurrent(),i)</span><br><span class="line">g1=gevent.spawn(work,2)</span><br><span class="line">g2=gevent.spawn(work,3)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&lt;Greenlet at 0x2177fb5ae18: work(2)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x2177fb5ae18: work(2)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x21700338048: work(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x21700338048: work(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x21700338048: work(3)&gt; 2</span><br></pre></td></tr></table></figure></p>
<pre><code>由例子可得出程序是先完全执行完g1对象，再执行g2--------原因是在此程序中无IO操作，无需进行协程切换
注：spawn:引发、导致、造成
</code></pre><p>例子改写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import gevent,time</span><br><span class="line">def work(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        ##获取当前协程的属性</span><br><span class="line">        print(gevent.getcurrent(),i)</span><br><span class="line">        gevent.sleep(1)  ##让协程睡眠</span><br><span class="line">g1=gevent.spawn(work,2)</span><br><span class="line">g2=gevent.spawn(work,3)</span><br><span class="line">##阻塞,程序资源不被释放</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">输出：</span><br><span class="line">&lt;Greenlet at 0x2177fb5ad08: work(2)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x2177fb5abf8: work(3)&gt; 0</span><br><span class="line">&lt;Greenlet at 0x2177fb5ad08: work(2)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x2177fb5abf8: work(3)&gt; 1</span><br><span class="line">&lt;Greenlet at 0x2177fb5abf8: work(3)&gt; 2</span><br></pre></td></tr></table></figure></p>
<pre><code>可以发现这次实现了协程切换。。。遗憾的是，如果换成time.sleep(1)从本质上看也拥有了IO操作，但并不能触发协程，原因是Gevent无法识别这类IO操作。
解决方法：打补丁---------from gevent import monkey---------官方建议是程序开始就开始打补丁
</code></pre><p>例如在以上例子在程序开头加上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all()</span><br></pre></td></tr></table></figure></p>
<p>这样的话把上面例子的gevent.sleep(1)改为time.sleep(1)也是同样结果</p>
<p>想让程序处于阻塞状态，切换协程的两种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    g1=gevent.spawn(work1)</span><br><span class="line">    g2=gevent.spawn(work2)</span><br><span class="line">    while True:</span><br><span class="line">        print(&quot;hello word&quot;)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    #g1.join()</span><br><span class="line">    #g2.join()</span><br></pre></td></tr></table></figure></p>
<p>①使用循环，在循环中进行IO操作    ②join函数阻塞</p>
<h3 id="Gevent-爬虫-实战训练"><a href="#Gevent-爬虫-实战训练" class="headerlink" title="Gevent+爬虫 实战训练"></a>Gevent+爬虫 实战训练</h3><pre><code>爬虫流程： 找到资源链接-——获取资源————将资源数据写入到本地文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line">import time,gevent,urllib.request</span><br><span class="line">def drowload_img(img_url,img_name):</span><br><span class="line">    try:</span><br><span class="line">        print(img_url)</span><br><span class="line">        reponse=urllib.request.urlopen(img_url)</span><br><span class="line">        with open(img_name,&apos;wb&apos;) as img_file:</span><br><span class="line">            while True:</span><br><span class="line">                img_data=reponse.read(1024)</span><br><span class="line">                if img_data:</span><br><span class="line">                    img_file.write(img_data)</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;图片下载异常：&quot;,e)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;图片下载成功&apos;,img_name)</span><br><span class="line">    pass</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    img_url1 = &apos;http://p0.so.qhmsg.com/bdr/576__/t013ee81b64eb53f6f5.jpg&apos;</span><br><span class="line">    img_url2 = &quot;http://p2.so.qhimgs1.com/bdr/594__/t017ec94ec006189032.jpg&quot;</span><br><span class="line">    img_url3 = &quot;http://p3.so.qhmsg.com/bdr/864__/t01f9daf42a666bb408.jpg&quot;</span><br><span class="line">    g1=gevent.spawn(drowload_img,img_url1,&quot;img_url1.jpg&quot;)</span><br><span class="line">    g2=gevent.spawn(drowload_img,img_url2,&quot;img_url2.jpg&quot;)</span><br><span class="line">    g3=gevent.spawn(drowload_img,img_url3,&quot;img_url3.jpg&quot;)</span><br><span class="line">    gevent.joinall([g1,g2,g3])</span><br><span class="line">结果：</span><br><span class="line">图片下载成功 img_url1.jpg</span><br><span class="line">图片下载成功 img_url3.jpg</span><br><span class="line">图片下载成功 img_url2.jpg</span><br></pre></td></tr></table></figure>
<p>本次每次写入1024个字节，img_url2.jpg图片最大，根据协程转换，一般会最后下载成功。（每次运行的结果可能不同）</p>
<h4 id="实战升级————爬取360网络图片"><a href="#实战升级————爬取360网络图片" class="headerlink" title="实战升级————爬取360网络图片"></a>实战升级————爬取360网络图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey</span><br><span class="line">#打补丁，识别网路延迟</span><br><span class="line">monkey.patch_all()</span><br><span class="line">import gevent,requests#pip install requests</span><br><span class="line">from urllib import request</span><br><span class="line">#下载图片</span><br><span class="line">def download_img(num):</span><br><span class="line">    #开启下载</span><br><span class="line">    print(&apos;start download&apos;)</span><br><span class="line">    #图片的url地址</span><br><span class="line">    url = &apos;http://image.so.com/zj?ch=beauty&amp;sn=150&amp;listtype=new&amp;temp=1&apos;</span><br><span class="line">    #模拟浏览器</span><br><span class="line">    headers=&#123;</span><br><span class="line">        &apos;Referer&apos;: &apos;http://image.so.com/z?ch=beauty&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    #模拟浏览器访问服务器发送内容</span><br><span class="line">    str_data = &apos;&apos;&apos;h: beauty</span><br><span class="line">    sn: 30</span><br><span class="line">    listtype: new</span><br><span class="line">    temp: 1&apos;&apos;&apos;</span><br><span class="line">    #简单的数据清洗</span><br><span class="line">    send_data = &#123;&#125;</span><br><span class="line">    #进行一行分割</span><br><span class="line">    for data in str_data.splitlines():</span><br><span class="line">        line_data = data.split(&apos;: &apos;)#返回一个列表</span><br><span class="line">        if len(line_data) == 2:#如果这个列表当中有两个数据</span><br><span class="line">            key,value = line_data# a,b = [1,2] #进行序列解包赋值！</span><br><span class="line">            if key and value:#如果两者key和 value都有值 我就进行 搭建send_data</span><br><span class="line">                send_data[key] = value</span><br><span class="line">    #end_data = &#123;&apos;h&apos;:&apos;beauty&apos;,&apos;sn&apos;:&apos;30&apos;&#125;</span><br><span class="line">    send_data[&apos;sn&apos;] = eval(str(num)+&apos;*&apos;+&apos;30&apos;) #eval（&apos;3 * 4&apos;）#z字典的修改</span><br><span class="line">    #requests 这个方法进行网略请求，模拟刘燃气访问服务器返回结果</span><br><span class="line">    response = requests.get(url,headers=headers,params=send_data)</span><br><span class="line">    #json()方法 转换为python可操作对象&#123;‘a&quot; ;1&#125;</span><br><span class="line">    json_data = response.json()[&apos;list&apos;]</span><br><span class="line">    #利用么酷的方法，序列解包赋值</span><br><span class="line">    for index,src in enumerate(json_data):</span><br><span class="line">        #获取图片url地址</span><br><span class="line">        image_url = src[&apos;qhimg_url&apos;]</span><br><span class="line">        try:</span><br><span class="line">            #给定本地图片地址</span><br><span class="line">            image_name = &apos;./360_image/&apos;+image_url[-8:]</span><br><span class="line">            #吧网路上的图片下载到本地</span><br><span class="line">            request.urlretrieve(url=image_url,filename=image_name)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">        else:</span><br><span class="line">            #format格式化</span><br><span class="line">            print(&apos;&#123;&#125; is download&apos;.format(image_name))</span><br><span class="line">        print(&apos;image is download&apos;)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    num = int(input(&apos;你想要爬取的图片的组:&apos;))</span><br><span class="line">    #列表推导式完成协程任务分发</span><br><span class="line">    gevent.joinall([gevent.spawn(download_img,i)for i in range(1,num+1)])</span><br></pre></td></tr></table></figure>
<h5 id="本部分主要偏于爬虫方面，需要使用到一定的html和网络通信协议这方面的知识"><a href="#本部分主要偏于爬虫方面，需要使用到一定的html和网络通信协议这方面的知识" class="headerlink" title="本部分主要偏于爬虫方面，需要使用到一定的html和网络通信协议这方面的知识"></a>本部分主要偏于爬虫方面，需要使用到一定的html和网络通信协议这方面的知识</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://LiYuanSh.github.io/2019/04/13/Django数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiYuanShu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小树窝">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/Django数据库/" itemprop="url">Django数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-13T11:38:15+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用Django开发一个网站，可能需要读取之前存在数据库中的数据。实现模型与数据库中表映射，即根据数据库生成ORM模型<br>本次主要使用inspectdb命令自动生成模型</p>
<h4 id="设置setting-py文件"><a href="#设置setting-py文件" class="headerlink" title="设置setting.py文件"></a>设置setting.py文件</h4><p>通过配置setting.py文件来连接数据库,以下是修改信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &apos;default&apos;: &#123;</span><br><span class="line">        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,</span><br><span class="line">        &apos;NAME&apos;:&apos;phone&apos;,</span><br><span class="line">        &apos;USER&apos;:&apos;root&apos;,</span><br><span class="line">        &apos;PASSWORD&apos;:&apos;123456&apos;,</span><br><span class="line">        &apos;HOST&apos;:&apos;127.0.0.1&apos;,</span><br><span class="line">        &apos;PORT&apos;:&apos;3306&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="cmd命令生成"><a href="#cmd命令生成" class="headerlink" title="cmd命令生成"></a>cmd命令生成</h4><p> 通过cmd进入到django项目，执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py inspectdb</span><br></pre></td></tr></table></figure></p>
<p>可惜并没有成功，发生了一个错误<br> 一、在执行命令后最后两行提示以下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: Error loading MySQLdb module.</span><br><span class="line">Did you install mysqlclient?</span><br></pre></td></tr></table></figure></p>
<p>可以看错这个错误是加载不到MYSQLdb模块导致的，可是我的项目运行环境中明明已经饱和这个模块了。百思不得其解，只能通过某度寻找答案了，原因是：python版本原因，python3需要在<strong>init</strong>.py文件中导入这个模块才行，即加入以下两行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></p>
<p>之后再执行命令成功</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">LiYuanShu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiYuanShu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
